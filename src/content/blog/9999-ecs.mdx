---
slug: ecs
title: Running Python Code in ECS with uv
meta_title: xx
description: xxx
date: 2025-10-24
image: /images/blog/9999-ship-python-containers.jpg
category: cloud_devops
tags: [AWS, Tutorial, Docker]
draft: false
---

## 1. Introduction

Running Python jobs on ECS can quickly get heavy if each container rebuilds dependencies. Using **uv** and a two-stage Docker design, we can separate dependency packaging from runtime execution, resulting in faster, smaller, and more reproducible deployments.

## 2. Building the Virtual Environment — `Dockerfile.venv`

**Goal:** Package a fully ready Python environment into a `.tar.gz` file.

**Highlights:**

* Use `uv` instead of `pip` or `poetry`.
* Create the environment with `uv venv --copies` and install with `uv sync --frozen --no-dev`.
* Bundle the venv into `venv_<version>.tar.gz` for deployment.

**Why:** The venv is portable, cached in S3, and reusable across ECS tasks — eliminating dependency rebuilds.

## 3. Runtime Image — `Dockerfile.runtime`

**Goal:** Run jobs fast without `uv` or build dependencies.

**Highlights:**

* Uses `python:3.13-slim-bookworm` (small, clean, fast).
* Installs only `boto3`, `click`, and `loguru` to fetch and run code.
* Downloads the prebuilt venv from S3, extracts it, and runs the job.

**Why:** The runtime container is lightweight and generic — every ECS job version loads the correct venv dynamically.

## 4. Entrypoint Script — `setup_and_run.sh`

**Goal:** Automate venv setup and execution.

**Steps:**

1. Download `pyproject.toml`, `uv.lock`, `entrypoint.py`, and the venv tarball.
2. Extract the venv locally.
3. Activate it.
4. Run `entrypoint.py` with passed ECS arguments.

**Why:** This makes the container completely version-agnostic — the job logic and dependencies live outside the image.

## 5. ECS Integration and Versioning

Each ECS task specifies a version tag (e.g., `-v uv`, `-v 0.7.1.villoro`). The runtime fetches that version’s artifacts from S3, allowing:

* Blue/green testing.
* Version pinning.
* Iteration without image rebuilds.

## 6. CI/CD Workflow

**Automation pipeline:**

* `Dockerfile.venv`: builds and uploads venv tarball to S3.
* `Dockerfile.runtime`: builds and pushes the runtime image to ECR.
* GitHub Actions separates both stages with clear version tagging and caching.

## 7. Troubleshooting & Best Practices

* Use LF line endings (`.gitattributes`):

  ```
  *.sh text eol=lf
  *.py text eol=lf
  ```
* Always build venvs with `uv venv --copies` to avoid absolute symlinks.
* For Python 3.14+, extract tarballs with `filter="fully_trusted"`.
* Store S3 paths and constants in a shared `utils.py`.

## 8. Closing Thoughts

This approach gives you:

* Instant ECS startup (no dependency rebuilds).
* Fully reproducible, versioned environments.
* Small and secure runtime images.
* Clean separation between build and execution.

By combining **uv**, **Docker**, and **S3**, you achieve a deployment model that’s simple, fast, and production-ready.
