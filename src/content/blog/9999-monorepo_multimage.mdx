---
slug: monorepo-multimage
title: Scaling ECS Python Deployments with a Modular Monorepo
meta_title: xxx
description: xx
date: 2025-11-07
image: /images/blog/9999-factory-line-packages.jpg
category: DE
tags: [DE]
draft: false
---

## 0. Introduction: From One Package to Many

Recap the motivation: cold starts, ECS performance, and the need for reproducibility. Link to the previous post and explain that this is the next stageâ€”growing from a single package to a scalable multi-package monorepo.

## 1. Single Package Limitations

Show how the original setup (e.g., `ecs_northius`) worked well initially, but why it doesn't scale for:

* Reuse across domains
* Shared tooling/code
* Independent versioning

## 2. Monorepo Design Patterns

Explain two strategies:

### 2.1. Single Workspace (monolithic `pyproject.toml`)

* Pros: simple dev experience, flat lockfile
* Cons: tight coupling, slow lock/builds, CI noise

### 2.2. Multi-Workspace Monorepo (per-package `pyproject.toml`)

* Pros: isolated deps/locks, clean CI, parallel release/versioning
* Cons: slightly more config (e.g., nested virtualenvs)

## 3. Shared Code Across Packages

Describe how to:

* Create a shared package (e.g., `nt_common`) with its own lock and version
* Use `uv add ../nt_common` from other packages like `ecs_northius`
* Avoid hardcoding paths; rely on `pyproject.toml` dependencies

## 4. Import Tests to Validate Setup

Ensure imports work **before shipping a package**:

* Use `importlib` to discover all modules in a package
* Parametrize `pytest` to attempt importing each `.py` file
* Skip `tests/` and hidden paths

## 5. CD with Docker + uv: Parametrized and Repeatable

### 5.1. Generic `Dockerfile.venv`

* Accepts `PACKAGE_NAME` and `PACKAGE_VERSION`
* Builds the venv from source
* Installs deps, copies code, installs it non-editable
* Outputs `venv_<version>.tar.gz`

### 5.2. Matrix-based GitHub Workflow

* CD uses a matrix of `{ name, tag_prefix }`
* Each job runs **only if its paths changed** (via `dorny/paths-filter`)
* Tags versions independently with `tag_prefix`

## 6. CI per Package

* Each package has independent `pytest` logic using `uv`
* Optionally include smoke tests for shared packages (e.g., `nt_common`)
* Matrix can also apply here to avoid unnecessary jobs

## 7. Optional: Gate Jobs + Branch Protection

Aggregate results of matrix jobs into one gate check. Clean up noisy PR checks and enforce atomic results.

## 8. Summary: Reusable, Fast, Independent

This structure allows you to:

* Reuse packages without duplication
* Independently version and tag apps/libs
* Use `uv` consistently for lockfile discipline
* Run light, versioned deployments on ECS
