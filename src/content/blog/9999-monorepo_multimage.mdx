---
slug: monorepo-multimage
title: Scaling ECS Python Deployments with a Modular Monorepo
meta_title: xxx
description: xx
date: 2025-11-07
image: /images/blog/9999-factory-line-packages.jpg
category: DE
tags: [DE]
draft: false
---

## 0. Intro

Every project starts small. In our case, it was a straightforward ELT setup focused on extracting data from APIs and storing it cleanly. At the time, we didn’t need a complex monorepo—just a single workspace with a small set of interdependent packages.

As the team grew and the project evolved to cover more diverse domains (scraping, ML jobs, RDS interactions etc.) we needed a way to modularize, test, and deploy independently. That’s when we shifted to a multi-workspace monorepo.

This post explains how we made that evolution: from a single-package workspace to a scalable, cleanly isolated monorepo with CI/CD tailored for each package.

## 1. Monorepo Design Options

When you start a Python monorepo, you typically have two options:

1. A single **shared workspace** (like one `uv venv` covering everything).
2. Multiple **independent workspaces** (one per package).

Let’s look at each.

### 1.1 Single Workspace: Easy at First

<Notice type="info">
  This is a great starting point. It keeps things simple while you're focused on building a single flow or service.
</Notice>

In the initial phase of a project, having a single workspace is ideal:

* Just one `pyproject.toml` for all code
* One venv (via `uv venv`) to manage everything
* Easy to run tests, build, or deploy

This is the setup described in <FancyLink linkText="Fast and Reproducible Python Deployments on ECS with uv" url="https://villoro.com/blog/fast-python-ecs-with-uv/" dark="true" />.

But as the codebase expands to include APIs, ML pipelines, or connectors, the single workspace model starts to break down—dependency conflicts emerge (e.g., `prefect` needing `package_x<3` while `pandas` needs `package_x>=4`), and even simple jobs end up dragging massive venvs due to heavyweight libraries.

### 1.2 Multi-Workspace: Scales Better

When packages become logically independent (e.g. `nt_sdk`, `nt_rds`, `nt_ml`), a multi-workspace monorepo makes more sense:

* Each package has its own `pyproject.toml`
* Each has its own `uv venv`
* Each defines only what it needs (faster builds, smaller deploys)

```plaintext
src/
├─ nt_common/       # shared code (utils, schemas, etc.)
├─ nt_rds/          # jobs that interact with databases
├─ nt_api/          # API jobs
└─ nt_ml/           # ML jobs
```

<Notice type="success" className="mt-6">
  Multi-workspace setups improve modularity, CI/CD speed, and team ownership. They also make it easier to plug different packages into different deploy targets.
</Notice>

In the next section, we’ll explain the benefits in more detail and how we organized the transition.

## 2. Monorepo with Multiple Workspaces

When splitting a growing project into independent parts, the first challenge is organizing the codebase. 

I recommend the following structure:

```plaintext
src/
├─ nt_common/
|  ├─ pyproject.toml
|  ├─ uv.lock
|  ├─ nt_common/
|  └─ tests/
├─ nt_api/
|  ├─ pyproject.toml
|  ├─ uv.lock
|  ├─ nt_common/
|  └─ tests/
└─ nt_rds/
   ├─ pyproject.toml
   ├─ uv.lock
   ├─ nt_common/
   └─ tests/
```

Each top-level folder inside `src/` represents a standalone package with its own dependencies, tests, and isolated environment.

<Notice type="info" className="mt-6">
  While it’s possible to have a single workspace that includes all packages, using independent workspaces provides better isolation, easier testing, and faster deployment for modular systems.
</Notice>

### 2.1 Creating Shared Code with `nt_common`

Sometimes, packages need to share common logic—models, helpers, utilities. That’s where `nt_common` comes in. It behaves like any other package but is added as a local dependency to others.

Steps:

1. Create `src/nt_common/pyproject.toml` and define your shared code in `src/nt_common/nt_common/`
2. From any other workspace (e.g., `nt_api`):

```bash
cd src/nt_api
uv add ../nt_common
```

This installs `nt_common` as a **built wheel**, with its pinned dependencies from its own `uv.lock`.

## 4. Import Tests to Validate Setup

Ensure imports work **before shipping a package**:

* Use `importlib` to discover all modules in a package
* Parametrize `pytest` to attempt importing each `.py` file
* Skip `tests/` and hidden paths

## 5. CD with Docker + uv: Parametrized and Repeatable

### 5.1. Generic `Dockerfile.venv`

* Accepts `PACKAGE_NAME` and `PACKAGE_VERSION`
* Builds the venv from source
* Installs deps, copies code, installs it non-editable
* Outputs `venv_<version>.tar.gz`

### 5.2. Matrix-based GitHub Workflow

* CD uses a matrix of `{ name, tag_prefix }`
* Each job runs **only if its paths changed** (via `dorny/paths-filter`)
* Tags versions independently with `tag_prefix`

## 6. CI per Package

* Each package has independent `pytest` logic using `uv`
* Optionally include smoke tests for shared packages (e.g., `nt_common`)
* Matrix can also apply here to avoid unnecessary jobs

## 7. Optional: Gate Jobs + Branch Protection

Aggregate results of matrix jobs into one gate check. Clean up noisy PR checks and enforce atomic results.

## 8. Summary: Reusable, Fast, Independent

This structure allows you to:

* Reuse packages without duplication
* Independently version and tag apps/libs
* Use `uv` consistently for lockfile discipline
* Run light, versioned deployments on ECS
