---
slug: monorepo-multimage
title: Scaling ECS Python Deployments with a Modular Monorepo
meta_title: xxx
description: xx
date: 2025-11-07
image: /images/blog/9999-factory-line-packages.jpg
category: DE
tags: [DE]
draft: false
---

## 0. Intro

Every project starts small. In our case, it was a straightforward ELT setup focused on extracting data from APIs and storing it cleanly. At the time, we didn’t need a complex monorepo—just a single workspace with a small set of interdependent packages.

As the team grew and the project evolved to cover more diverse domains (scraping, ML jobs, RDS interactions etc.) we needed a way to modularize, test, and deploy independently. That’s when we shifted to a multi-workspace monorepo.

This post explains how we made that evolution: from a single-package workspace to a scalable, cleanly isolated monorepo with CI/CD tailored for each package.

## 1. Monorepo Design Options

When you start a Python monorepo, you typically have two options:

1. A single **shared workspace** (like one `uv venv` covering everything).
2. Multiple **independent workspaces** (one per package).

Let’s look at each.

### 1.1 Single Workspace: Easy at First

<Notice type="info">
  This is a great starting point. It keeps things simple while you're focused on building a single flow or service.
</Notice>

In the initial phase of a project, having a single workspace is ideal:

* Just one `pyproject.toml` for all code
* One venv (via `uv venv`) to manage everything
* Easy to run tests, build, or deploy

This is the setup described in <FancyLink linkText="Fast and Reproducible Python Deployments on ECS with uv" url="https://villoro.com/blog/fast-python-ecs-with-uv/" dark="true" />.

But as the codebase expands to include APIs, ML pipelines, or connectors, the single workspace model starts to break down—dependency conflicts emerge (e.g., `prefect` needing `package_x<3` while `pandas` needs `package_x>=4`), and even simple jobs end up dragging massive venvs due to heavyweight libraries.

### 1.2 Multi-Workspace: Scales Better

When packages become logically independent (e.g. `nt_sdk`, `nt_rds`, `nt_ml`), a multi-workspace monorepo makes more sense:

* Each package has its own `pyproject.toml`
* Each has its own `uv venv`
* Each defines only what it needs (faster builds, smaller deploys)

```plaintext
src/
├─ nt_common/       # shared code (utils, schemas, etc.)
├─ nt_sdk/          # SDK for external use
├─ nt_rds/          # RDS connector
├─ nt_api/          # REST API
└─ nt_ml/           # ML utilities
```

<Notice type="success" className="mt-6">
  Multi-workspace setups improve modularity, CI/CD speed, and team ownership. They also make it easier to plug different packages into different deploy targets.
</Notice>

In the next section, we’ll explain the benefits in more detail and how we organized the transition.

## 2. Monorepo Design Patterns

Explain two strategies:

### 2.1. Single Workspace (monolithic `pyproject.toml`)

* Pros: simple dev experience, flat lockfile
* Cons: tight coupling, slow lock/builds, CI noise

### 2.2. Multi-Workspace Monorepo (per-package `pyproject.toml`)

* Pros: isolated deps/locks, clean CI, parallel release/versioning
* Cons: slightly more config (e.g., nested virtualenvs)

## 3. Shared Code Across Packages

Describe how to:

* Create a shared package (e.g., `nt_common`) with its own lock and version
* Use `uv add ../nt_common` from other packages like `ecs_northius`
* Avoid hardcoding paths; rely on `pyproject.toml` dependencies

## 4. Import Tests to Validate Setup

Ensure imports work **before shipping a package**:

* Use `importlib` to discover all modules in a package
* Parametrize `pytest` to attempt importing each `.py` file
* Skip `tests/` and hidden paths

## 5. CD with Docker + uv: Parametrized and Repeatable

### 5.1. Generic `Dockerfile.venv`

* Accepts `PACKAGE_NAME` and `PACKAGE_VERSION`
* Builds the venv from source
* Installs deps, copies code, installs it non-editable
* Outputs `venv_<version>.tar.gz`

### 5.2. Matrix-based GitHub Workflow

* CD uses a matrix of `{ name, tag_prefix }`
* Each job runs **only if its paths changed** (via `dorny/paths-filter`)
* Tags versions independently with `tag_prefix`

## 6. CI per Package

* Each package has independent `pytest` logic using `uv`
* Optionally include smoke tests for shared packages (e.g., `nt_common`)
* Matrix can also apply here to avoid unnecessary jobs

## 7. Optional: Gate Jobs + Branch Protection

Aggregate results of matrix jobs into one gate check. Clean up noisy PR checks and enforce atomic results.

## 8. Summary: Reusable, Fast, Independent

This structure allows you to:

* Reuse packages without duplication
* Independently version and tag apps/libs
* Use `uv` consistently for lockfile discipline
* Run light, versioned deployments on ECS
