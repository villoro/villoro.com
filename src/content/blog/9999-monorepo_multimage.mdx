---
slug: monorepo-multimage
title: Scaling ECS Python Deployments with a Modular Monorepo
meta_title: xxx
description: xx
date: 2025-11-07
image: /images/blog/9999-factory-line-packages.jpg
category: DE
tags: [DE]
draft: false
---

## 0. Intro

Every project starts small. In our case, it was a straightforward ELT setup focused on extracting data from APIs and storing it cleanly. At the time, we didn’t need a complex monorepo—just a single workspace with a small set of interdependent packages.

As the team grew and the project evolved to cover more diverse domains (scraping, ML jobs, RDS interactions etc.) we needed a way to modularize, test, and deploy independently. That’s when we shifted to a multi-workspace monorepo.

This post explains how we made that evolution: from a single-package workspace to a scalable, cleanly isolated monorepo with CI/CD tailored for each package.

<Notice type="success">
  The setup described in <FancyLink linkText="Fast and Reproducible Python Deployments on ECS with uv" url="https://villoro.com/blog/fast-python-ecs-with-uv/" dark="true"/> (single workspace, one uv-managed package) is the **recommended starting point**. It’s simple, fast, and avoids unnecessary complexity.
</Notice>

## 1. Single Package Limitations

Show how the original setup (e.g., `ecs_northius`) worked well initially, but why it doesn't scale for:

* Reuse across domains
* Shared tooling/code
* Independent versioning

## 2. Monorepo Design Patterns

Explain two strategies:

### 2.1. Single Workspace (monolithic `pyproject.toml`)

* Pros: simple dev experience, flat lockfile
* Cons: tight coupling, slow lock/builds, CI noise

### 2.2. Multi-Workspace Monorepo (per-package `pyproject.toml`)

* Pros: isolated deps/locks, clean CI, parallel release/versioning
* Cons: slightly more config (e.g., nested virtualenvs)

## 3. Shared Code Across Packages

Describe how to:

* Create a shared package (e.g., `nt_common`) with its own lock and version
* Use `uv add ../nt_common` from other packages like `ecs_northius`
* Avoid hardcoding paths; rely on `pyproject.toml` dependencies

## 4. Import Tests to Validate Setup

Ensure imports work **before shipping a package**:

* Use `importlib` to discover all modules in a package
* Parametrize `pytest` to attempt importing each `.py` file
* Skip `tests/` and hidden paths

## 5. CD with Docker + uv: Parametrized and Repeatable

### 5.1. Generic `Dockerfile.venv`

* Accepts `PACKAGE_NAME` and `PACKAGE_VERSION`
* Builds the venv from source
* Installs deps, copies code, installs it non-editable
* Outputs `venv_<version>.tar.gz`

### 5.2. Matrix-based GitHub Workflow

* CD uses a matrix of `{ name, tag_prefix }`
* Each job runs **only if its paths changed** (via `dorny/paths-filter`)
* Tags versions independently with `tag_prefix`

## 6. CI per Package

* Each package has independent `pytest` logic using `uv`
* Optionally include smoke tests for shared packages (e.g., `nt_common`)
* Matrix can also apply here to avoid unnecessary jobs

## 7. Optional: Gate Jobs + Branch Protection

Aggregate results of matrix jobs into one gate check. Clean up noisy PR checks and enforce atomic results.

## 8. Summary: Reusable, Fast, Independent

This structure allows you to:

* Reuse packages without duplication
* Independently version and tag apps/libs
* Use `uv` consistently for lockfile discipline
* Run light, versioned deployments on ECS
