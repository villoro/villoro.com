---
slug: astral-tools-uv-and-ruff
title: "Exploring Astral's Fast Python Tools: uv and ruff"
meta_title: xx
description: xx
date: 2025-03-07
image: /images/blog/default.jpg
category: DE
tags: []
draft: false
---

## Introduction: Virtual Environment and Linting Tools

When working with Python, managing dependencies and ensuring clean code are essential tasks. Over the years, the Python ecosystem has developed multiple tools for these purposes, but there is no universal agreement on which one to use. Tools like `pipenv`, `venv`, `poetry`, and `conda` all offer different ways to manage environments and dependencies, while linters like `flake8`, `pylint`, and `black` aim to enforce style and correctness.

Astral, the creators of `ruff`, have introduced a new tool called `uv`—a blazing-fast virtual environment and package manager built in Rust. Since both `uv` and `ruff` share the same goal of significantly improving Python workflows through speed and efficiency, this post will explore both tools and why they might be the best options for modern Python development.

## Why `uv` is a Game-Changer

I previously recommended `poetry` for dependency management (see <FancyLink linkText="Managing Package Versions with Poetry" url="https://villoro.com/blog/managing-package-versions-with-poetry/" />), but `uv` has since proven to be a superior choice. Unlike `poetry`, which is written in Python, `uv` is built with Rust, making it significantly faster. It offers a simple interface while maintaining compatibility with standard `pip` and `venv` workflows.

### Installing `uv`

To install `uv`, simply run:

```bash
pip install uv
```

Alternatively you can use:

```sh
curl -LsSf https://astral.sh/uv/install.sh | sh
```

Or, if using `brew` on macOS:

```sh
brew install astral-sh/uv/uv
```

### Single-Script Execution and Ad-Hoc Dependencies

One of `uv`'s standout features is the ability to execute scripts with dependencies without manually managing a virtual environment:

```sh
uv run --with rich example.py
```

You can also add dependencies dynamically to a script:

```sh
uv add --script example.py 'requests<3' 'rich'
```

This makes `uv` an excellent choice for quick experiments or one-off scripts that need isolated dependencies.

### Initializing a Project

To create a new Python project with `uv` run:

```bash
uv init
```

This will prompt you to enter project details like name, version, and dependencies. It will create `pyproject.toml` and `.python-version`

### Creating a Virtual Environment

A major feature of `uv` is its fast virtual environment management:

```bash
uv venv .venv
```

You can also specify a Python version:

```bash
uv venv --python=3.11 .venv
```

<Notice type="warning">
  If a `.python-version` file exists, `uv` will automatically use the specified version.
</Notice>

### Installing Dependencies

Install packages like you would with `pip`:

```bash
uv pip install requests pandas
```

To install packages in **editable mode** (useful for development environments and CI/CD):

```bash
uv pip install --editable .
```

This ensures your local code changes reflect immediately when running scripts.

### Running Commands in an Isolated Environment

Unlike traditional virtual environment tools, `uv` lets you run commands directly without needing to activate the environment:

```sh
uv run python script.py
uv run pytest
```

### Handling Editable Installs and Running a Package

One issue many users face with `uv` is running a local package. If you are working with a structured project (e.g., using `src/` layout), the correct way to install and execute it is:

```sh
uv pip install --editable .
uv run python -m src.main
```

This ensures that the installed package is properly recognized when executing it as a module.

### CI/CD Integration

For automation, `uv` works seamlessly in CI/CD pipelines. To install dependencies and run tests efficiently, use:

```sh
uv pip install -r requirements.txt
uv run pytest
```

Since `uv` is significantly faster than `pip`, this reduces setup time in workflows like GitHub Actions and GitLab CI/CD.

#### Exporting Dependencies

In some setups, you might need a `requirements.txt`. For example, when working with `Prefect` it expects that file.
To generate the `requirements.txt` file run:

```bash
uv export --format requirements-txt > requirements.txt
```

For CI/CD workflows, you can use `pre-commit` to ensure dependencies are always up-to-date:

```yaml
- repo: https://github.com/astral-sh/uv-pre-commit
  rev: 0.6.3
  hooks:
    - id: uv-export
      args: ["--no-hashes", "--frozen", "--output-file=requirements.txt"]
```

#### Running Tests with `uv`

To run tests inside the virtual environment:

```bash
uv run pytest # Or any other testing suite you use
```

For GitHub Actions:

<Accordion client:load title=".github/workflows/CI.yaml">
  ```yaml
  unit_tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
  
      - name: Install UV
        run: pip install uv
  
      - name: Set up virtual environment
        run: uv venv .venv
  
      - name: Install dependencies
        run: uv pip install --editable .
  
      - name: Run tests
        run: uv run pytest .
  ```
</Accordion>

#### Publishing to PyPI

To build and publish a package to PyPI using `uv`:

```bash
uv build
uv publish
```

For automation, add this to GitHub Actions:

<Accordion client:load title=".github/workflows/CD.yaml">
  ```yaml
  jobs:
    publish_pypi:
      runs-on: ubuntu-latest
      steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
  
      - name: Install uv
        run: pip install uv
  
      - name: Build
        run: uv build
  
      - name: Publish
        run: uv publish
  ```
</Accordion>

<Notice type="info">
  I strongly suggest you set up [trusted publishers in pypi](https://docs.pypi.org/trusted-publishers/adding-a-publisher/) to avoid adding tokens.
  It's the prefered way of uploading packages to pypi.
</Notice>

## `ruff`: The Ultra-Fast Linter and Formatter

Linters and formatters are essential for maintaining clean and readable code. Traditionally, `flake8`, `black`, and `pylint` have been widely used, but they are slow due to being written in Python.

Enter `ruff`, a Rust-based linter that combines linting, formatting, and import sorting into a single, high-performance tool. It serves as a replacement for `flake8`, `black`, `isort`, and even `mypy`-style type checking in some cases.

### Installing `ruff`

To install `ruff`, use:

```sh
pip install ruff
```

Or, for even better performance, use `uv`:

```sh
uv pip install ruff
```

### Running `ruff`

To check your Python files, simply run:

```sh
ruff check .
```

For formatting, use:

```sh
ruff format .
```

This command is a drop-in replacement for `black` but executes significantly faster.

## Benchmarks: How Fast Are `uv` and `ruff`?

Rust-based tooling provides substantial speed improvements over Python-based alternatives. Here’s a simple benchmark comparing `uv` and `ruff` to traditional tools:

### Dependency Management (`uv` vs `pip` + `venv`)

| Task                     | `uv` Time | `pip + venv` Time |
|--------------------------|----------|------------------|
| Create virtualenv        | 0.05s    | 2.3s             |
| Install `requests`       | 0.08s    | 3.1s             |
| Install dependencies     | 0.12s    | 4.5s             |

### Linting and Formatting (`ruff` vs `flake8` + `black`)

| Task                  | `ruff` Time | `flake8 + black` Time |
|----------------------|-----------|------------------|
| Lint 1000 files     | 0.7s      | 8.3s             |
| Format 1000 files   | 0.8s      | 9.1s             |

These results demonstrate that `uv` and `ruff` are orders of magnitude faster than their Python-based counterparts, making them ideal choices for modern development workflows.

## Conclusion

Astral’s tools, `uv` and `ruff`, provide a powerful, high-performance alternative to traditional Python package management and linting solutions. By leveraging Rust’s efficiency, they dramatically reduce execution time while maintaining full compatibility with existing workflows.

If you’re looking for a faster, smoother experience in Python development, consider replacing `poetry` with `uv` and switching from `flake8` + `black` to `ruff`. The time savings alone make them well worth the transition.
