---
slug: github-hooks
title: Scalable GitHub Actions for Modern Repos
meta_title: xxx
description: xx
date: 2025-11-07
image: /images/blog/9999-octopus-hooks.jpg
category: DE
tags: [DE]
draft: false
---

## 0. Intro

Creating maintainable and efficient GitHub Actions pipelines becomes critical when you manage multiple repositories or modular projects. This post walks through four key patterns to make your CI/CD setup scalable, reliable, and fast.

## 1. Reusable Hooks Across Repositories

When multiple repositories share CI logic, extract it into a reusable **composite action** that lives in a dedicated repo (e.g., `villoro/vhooks`). Consumers then call it with a single `uses:` line, keeping workflows DRY and consistent.

### 1.1 Repository Layout

A simple structure for multiple hooks:

```plaintext
vhooks/
â”œâ”€ check_version/
â”‚  â”œâ”€ action.yml          # composite action definition
â”‚  â”œâ”€ requirements.txt    # python deps (optional)
â”‚  â””â”€ check_version.py    # hook logic
â””â”€ tag_version/
   â”œâ”€ action.yml
   â”œâ”€ requirements.txt
   â””â”€ tag_version.py
```

<Notice type="info">
  Each folder under `vhooks` is a standalone hook. The `action.yml` defines its interface, while the Python file contains the logic.
</Notice>

### 1.2 Composite Action Definition

<TerminalOutput color="stone">
  `check_version/action.yml`
</TerminalOutput>
```yaml
name: Check Package Version
description: Checks if the package version has been updated compared to a specified branch, only when selected paths change.
author: Arnau Villoro

inputs:
  repository:
    description: Repository to check version in
    required: true
    default: ${{ github.repository }}

  ref:
    description: Branch/commit ref to evaluate
    required: true
    default: ${{ github.ref }}

  branch:
    description: Branch to compare the version with
    required: false
    default: main

  file:
    description: File to check version in (e.g., pyproject.toml, version.json)
    required: false
    default: pyproject.toml

  path:
    description: Path inside the file to extract the version
    required: false
    default: project/version

  filters:
    description: |
      YAML for dorny/paths-filter. Must define a 'code' key.
      Example:
        code:
          - 'src/ecs_northius/**'
    required: false
    default: |
      code:
        - '**'

runs:
  using: composite
  steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.repository }}
        ref: ${{ inputs.ref }}
        fetch-depth: 0

    - name: Fetch target branch
      shell: bash
      run: git fetch origin ${{ inputs.branch }} --depth=1

    - name: Detect path changes
      id: changes
      uses: dorny/paths-filter@v2
      with:
        # Compare specified ref against target branch
        base: origin/${{ inputs.branch }}
        ref: ${{ inputs.ref }}
        filters: ${{ inputs.filters }}

    - name: Install dependencies
      if: steps.changes.outputs.code == 'true'
      shell: bash
      run: pip install toml loguru packaging click pyyaml

    - name: Run version check
      if: steps.changes.outputs.code == 'true'
      shell: bash
      run: python "$GITHUB_ACTION_PATH/check_version.py" --branch="${{ inputs.branch }}" --file="${{ inputs.file }}" --path="${{ inputs.path }}"
```

### 1.3 Python Implementation

Below is the same version check logic, rewritten using **Click** for cleaner CLI handling.

<TerminalOutput color="stone">
  `check_version/check_version.py`
</TerminalOutput>
```python
import subprocess
from pathlib import Path
import click
import json

try:
    import tomllib  # Python 3.11+
except ModuleNotFoundError:
    import tomli as tomllib


def read_version(file_path, key_path):
    p = Path(file_path)
    if p.suffix == ".toml":
        data = tomllib.loads(p.read_text())
    elif p.suffix in {".yml", ".yaml"}:
        import yaml
        data = yaml.safe_load(p.read_text())
    elif p.suffix == ".json":
        data = json.loads(p.read_text())
    else:
        raise click.ClickException(f"Unsupported file type: {p.suffix}")

    node = data
    for part in key_path.split("/"):
        node = node[part]
    return str(node).strip()


def git_show(ref, file_path):
    out = subprocess.check_output(["git", "show", f"{ref}:{file_path}"])
    return out.decode()


def read_version_at_ref(ref, file_path, key_path):
    from tempfile import TemporaryDirectory
    tmp = TemporaryDirectory()
    p = Path(tmp.name) / Path(file_path).name
    p.write_text(git_show(ref, file_path))
    return read_version(p, key_path)


def version_tuple(s):
    return tuple(int(x) for x in s.split(".") if x.isdigit())


@click.command()
@click.option("--branch", default="main")
@click.option("--file", default="pyproject.toml")
@click.option("--path", default="project/version")
def main(branch, file, path):
    current = read_version(file, path)
    base = read_version_at_ref(branch, file, path)

    if version_tuple(current) <= version_tuple(base):
        raise click.ClickException(
            f"Version must be incremented. base={base} current={current}"
        )

    click.echo(f"âœ… OK: base={base} â†’ current={current}")


if __name__ == "__main__":
    main()
```

<Notice type="success">
  Using **Click** provides cleaner help messages, better error handling, and easy local testing (`python check_version.py --help`).
</Notice>

### 1.4 Consuming the Hook from Any Repo

Add a workflow that runs on PRs and references the released version of the hook:

```yaml
name: Check Version

on:
  pull_request:
    branches: [main]

jobs:
  check_version:
    runs-on: ubuntu-latest
    steps:
      - uses: villoro/vhooks/check_version@1.3.0
        with:
          branch: main
          file: pyproject.toml
          path: project/version
          filters: |
            code:
              - 'src/**'
              - 'pyproject.toml'
```

<Notice type="info">
  Always pin to a version tag like `@1.3.0` to avoid breaking changes from `main`.
</Notice>

### 1.5 Version Tagging Hook (Optional Example)

Expose a second action to tag commits when code changes in `main`:

```yaml
name: Tag Version
on:
  push:
    branches: [main]
permissions:
  contents: write
jobs:
  tag_version:
    runs-on: ubuntu-latest
    steps:
      - uses: villoro/vhooks/tag_version@1.3.0
        with:
          file: pyproject.toml
          path: project/version
          tag-prefix: v
```

<Notice type="info">
  You can combine `check_version` and `tag_version` for automatic version enforcement and tagging.
</Notice>

### 1.6 Best Practices

* Pin to immutable tags (e.g., `@1.3.0`).
* Keep each hook self-contained with its dependencies.
* Validate inputs and fail fast.
* Use `dorny/paths-filter` to skip unchanged packages.
* Document inputs/outputs clearly.

<Notice type="success">
  Reusable hooks turn CI logic into a modular library you can evolve across all your repos with minimal effort.
</Notice>

## 2. ðŸ§© Matrix Jobs â€” The Right Way

Matrix jobs let you run the same logic across multiple inputs (e.g., multiple packages). The key lessons:

### 2.1. Keep the Matrix Minimal

Avoid redundant fields like both `name` and `path` when one can derive the other.

Example:

```yaml
matrix:
  name:
    - ecs_northius
    - nt_common
```

Then derive everything else dynamically:

```yaml
working-directory: src/${{ matrix.name }}
```

### 2.2. Use Runtime Interpolation, Not Matrix Variables

Expressions like `${{ hashFiles() }}` donâ€™t work inside the matrix definition. Compute them at runtime instead:

```yaml
key: uv-${{ runner.os }}-${{ hashFiles(format('src/{0}/uv.lock', matrix.name)) }}
```

### 2.3. Use Filters to Trigger Only Whatâ€™s Needed

Combine `dorny/paths-filter` with matrix jobs so each package runs only if its files (or shared dependencies) changed:

```yaml
filters: |
  code:
    - 'src/${{ matrix.name }}/**'
    - 'src/nt_common/**'
```

Then conditionally run steps:

```yaml
if: steps.changes.outputs.code == 'true'
```

This prevents unnecessary builds or tests.

## 3. Gate Jobs â€” One Check to Rule Them All

Gate jobs aggregate matrix results so your branch protection rules only need one required check.

### 3.1. Example:

```yaml
pytest_gate:
  name: pytest_result
  needs: [pytests]
  runs-on: ubuntu-latest
  if: always()
  steps:
    - run: |
        echo "Matrix result: ${{ needs.pytests.result }}"
        if [ "${{ needs.pytests.result }}" != "success" ]; then
          echo "Some matrix jobs failed. See details in Actions run."
          exit 1
        fi
```

Now your branch protection only needs to require `pytest_result`, not each individual job.

## 4. Concurrency â€” Smarter, Not Harder

When you push new commits to a PR, older runs become obsolete. Cancel them automatically to save resources.

### 4.1. Example:

```yaml
name: CI_global

on:
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  pre_commit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
      - uses: pre-commit/action@v3.0.0
```

This ensures that only the latest workflow for each PR remains active.

## 5. Putting It All Together

These techniques form a cohesive CI/CD strategy:

* Reusable hooks for shared logic.
* Matrix jobs for scalable parallel execution.
* Gate jobs for clean PR checks.
* Concurrency to avoid redundant runs.

Together, they make your workflows **modular, efficient, and production-ready**.

## 6. Key Takeaways

* **Reusable hooks:** maintainable and DRY.
* **Matrix + filters:** scalable and efficient.
* **Gate jobs:** reliable single-point validation.
* **Concurrency:** resource-smart and fast.

Your CI should scale with your codebase â€” not slow it down.
