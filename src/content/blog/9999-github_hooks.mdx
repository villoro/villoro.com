---
slug: github-hooks
title: Scalable GitHub Actions for Modern Repos
meta_title: xxx
description: xx
date: 2025-11-07
image: /images/blog/9999-octopus-hooks.jpg
category: DE
tags: [DE]
draft: false
---

## 0. Intro

Creating maintainable and efficient GitHub Actions pipelines becomes critical when you manage multiple repositories or modular projects. This post walks through four key patterns to make your CI/CD setup scalable, reliable, and fast.

## 1. Reusable Hooks Across Repositories

When you have multiple repositories that share similar CI logic, itâ€™s best to centralize that logic into a **reusable action**. This keeps your pipelines DRY and consistent.

### Example: `vhooks`

You can store all shared hooks in a dedicated repo, like [`villoro/vhooks`](https://github.com/villoro/vhooks), and use them in any other workflow:

```yaml
yaml
jobs:
  pre_commit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: villoro/vhooks/.github/actions/pre-commit@main
```

This approach ensures that updating a hook in one place propagates improvements to all your repos automatically.

**Benefits:**

* DRY: define once, reuse everywhere.
* Consistent behavior across projects.
* Easy updates and versioning through tags or branches.

## 2. ðŸ§© Matrix Jobs â€” The Right Way

Matrix jobs let you run the same logic across multiple inputs (e.g., multiple packages). The key lessons:

### 2.1. Keep the Matrix Minimal

Avoid redundant fields like both `name` and `path` when one can derive the other.

Example:

```yaml
matrix:
  name:
    - ecs_northius
    - nt_common
```

Then derive everything else dynamically:

```yaml
working-directory: src/${{ matrix.name }}
```

### 2.2. Use Runtime Interpolation, Not Matrix Variables

Expressions like `${{ hashFiles() }}` donâ€™t work inside the matrix definition. Compute them at runtime instead:

```yaml
key: uv-${{ runner.os }}-${{ hashFiles(format('src/{0}/uv.lock', matrix.name)) }}
```

### 2.3. Use Filters to Trigger Only Whatâ€™s Needed

Combine `dorny/paths-filter` with matrix jobs so each package runs only if its files (or shared dependencies) changed:

```yaml
filters: |
  code:
    - 'src/${{ matrix.name }}/**'
    - 'src/nt_common/**'
```

Then conditionally run steps:

```yaml
if: steps.changes.outputs.code == 'true'
```

This prevents unnecessary builds or tests.

## 3. Gate Jobs â€” One Check to Rule Them All

Gate jobs aggregate matrix results so your branch protection rules only need one required check.

### 3.1. Example:

```yaml
pytest_gate:
  name: pytest_result
  needs: [pytests]
  runs-on: ubuntu-latest
  if: always()
  steps:
    - run: |
        echo "Matrix result: ${{ needs.pytests.result }}"
        if [ "${{ needs.pytests.result }}" != "success" ]; then
          echo "Some matrix jobs failed. See details in Actions run."
          exit 1
        fi
```

Now your branch protection only needs to require `pytest_result`, not each individual job.

## 4. Concurrency â€” Smarter, Not Harder

When you push new commits to a PR, older runs become obsolete. Cancel them automatically to save resources.

### 4.1. Example:

```yaml
name: CI_global

on:
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  pre_commit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
      - uses: pre-commit/action@v3.0.0
```

This ensures that only the latest workflow for each PR remains active.

## 5. Putting It All Together

These techniques form a cohesive CI/CD strategy:

* Reusable hooks for shared logic.
* Matrix jobs for scalable parallel execution.
* Gate jobs for clean PR checks.
* Concurrency to avoid redundant runs.

Together, they make your workflows **modular, efficient, and production-ready**.

## 6. Key Takeaways

* **Reusable hooks:** maintainable and DRY.
* **Matrix + filters:** scalable and efficient.
* **Gate jobs:** reliable single-point validation.
* **Concurrency:** resource-smart and fast.

Your CI should scale with your codebase â€” not slow it down.
