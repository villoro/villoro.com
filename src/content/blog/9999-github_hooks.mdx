---
slug: github-hooks
title: Scalable GitHub Actions for Modern Repos
meta_title: xxx
description: xx
date: 2025-11-07
image: /images/blog/9999-octopus-hooks.jpg
category: DE
tags: [DE]
draft: false
---

## 0. Intro

Creating maintainable and efficient GitHub Actions pipelines becomes critical when you manage multiple repositories or modular projects. This post walks through four key patterns to make your CI/CD setup scalable, reliable, and fast.

## 1. Reusable Hooks Across Repositories

When multiple repositories share CI logic, extract it into a reusable **composite action** that lives in a dedicated repo (e.g., `villoro/vhooks`). This pattern keeps your CI/CD logic consistent across projects while avoiding duplication.

### 1.1 Repository Layout

Start by organizing your hooks into separate folders, each representing a single reusable action.

```plaintext
vhooks/
‚îú‚îÄ check_version/
‚îÇ  ‚îú‚îÄ action.yml          # composite action definition
‚îÇ  ‚îú‚îÄ requirements.txt    # python deps (optional)
‚îÇ  ‚îî‚îÄ check_version.py    # hook logic
‚îî‚îÄ tag_version/
   ‚îú‚îÄ action.yml
   ‚îú‚îÄ requirements.txt
   ‚îî‚îÄ tag_version.py
```

<Notice type="info" className="mt-6">
  Each folder under `vhooks` is a standalone hook. The `action.yml` defines its interface, while the Python file contains the logic.
</Notice>

### 1.2 Composite Action Definition

The composite action serves as the glue between GitHub Actions and your Python script. It defines the inputs, runs any required setup, and calls your Python logic.

<TerminalOutput color="stone">
  `tag_version/action.yml`
</TerminalOutput>
```yaml
name: Tag Version
description: Tag with the version from a file only when selected paths change.
author: Arnau Villoro

inputs:
  branch:
    description: Branch to check the version from
    required: false
    default: main

  file:
    description: File to extract the version from (supports .toml, .json, .yml)
    required: false
    default: pyproject.toml

  path:
    description: Path inside the file to extract the version
    required: false
    default: project/version

  filters:
    description: |
      YAML for dorny/paths-filter. Must define a 'code' key.
      Example:
        code:
          - 'src/**'
    required: false
    default: |
      code:
        - '**'

runs:
  using: composite
  steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect changes
      id: changes
      uses: dorny/paths-filter@v2
      with:
        filters: ${{ inputs.filters }}

    - name: Install dependencies
      if: steps.changes.outputs.code == 'true'
      shell: bash
      run: pip install toml loguru click pyyaml

    - name: Extract version
      if: steps.changes.outputs.code == 'true'
      shell: bash
      run: python "$GITHUB_ACTION_PATH/tag_version.py" --file="${{ inputs.file }}" --path="${{ inputs.path }}"

    - name: Check if tag exists
      if: steps.changes.outputs.code == 'true'
      id: check_tag
      uses: mukunku/tag-exists-action@v1.4.0
      with:
        tag: ${{ env.VERSION }}

    - name: Create tag
      if: steps.changes.outputs.code == 'true' && steps.check_tag.outputs.exists != 'true'
      uses: actions/github-script@v7
      with:
        script: |
          github.rest.git.createRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: `refs/tags/${{ env.VERSION }}`,
            sha: context.sha
          })
```

### 1.3 Python Implementation

The Python script extracts the version from your file and pushes a new tag if it doesn‚Äôt exist yet.

<TerminalOutput color="stone">
  `tag_version/tag_version.py`
</TerminalOutput>
```python
import subprocess
from pathlib import Path
import click
import json

try:
    import tomllib  # Python 3.11+
except ModuleNotFoundError:
    import tomli as tomllib


def read_version(file_path, key_path):
    p = Path(file_path)
    if p.suffix == ".toml":
        data = tomllib.loads(p.read_text())
    elif p.suffix in {".yml", ".yaml"}:
        import yaml
        data = yaml.safe_load(p.read_text())
    elif p.suffix == ".json":
        data = json.loads(p.read_text())
    else:
        raise click.ClickException(f"Unsupported file type: {p.suffix}")

    node = data
    for part in key_path.split("/"):
        node = node[part]
    return str(node).strip()


def git(cmd):
    return subprocess.check_output(cmd, text=True).strip()


@click.command()
@click.option("--file", default="pyproject.toml")
@click.option("--path", default="project/version")
def main(file, path):
    version = read_version(file, path)
    tag = version

    existing_tags = git(["git", "tag", "--list", tag])
    if existing_tags:
        click.echo(f"‚ö†Ô∏è Tag {tag} already exists ‚Äî skipping.")
        return

    git(["git", "tag", tag])
    git(["git", "push", "origin", tag])
    click.echo(f"‚úÖ Created and pushed tag: {tag}")


if __name__ == "__main__":
    main()
````

### 1.4 Consuming the Hook from Any Repo

To use your new hook, create a simple workflow that triggers on `main` pushes and automatically tags new versions.

```yaml
name: Tag Version

on:
  push:
    branches: [main]
permissions:
  contents: write

jobs:
  tag_version:
    runs-on: ubuntu-latest
    steps:
      - uses: villoro/vhooks/tag_version@1.3.0
        with:
          file: pyproject.toml
          path: project/version
```

<Notice type="info" className="mt-6">
  Always pin to a version tag like `@1.3.0` to avoid breaking changes from `main`.
</Notice>

## 2. üß© Matrix Jobs ‚Äî The Right Way

Matrix jobs let you run the same logic across multiple inputs (e.g., multiple packages). The key lessons:

### 2.1. Keep the Matrix Minimal

Avoid redundant fields like both `name` and `path` when one can derive the other.

Example:

```yaml
matrix:
  name:
    - ecs_northius
    - nt_common
```

Then derive everything else dynamically:

```yaml
working-directory: src/${{ matrix.name }}
```

### 2.2. Use Runtime Interpolation, Not Matrix Variables

Expressions like `${{ hashFiles() }}` don‚Äôt work inside the matrix definition. Compute them at runtime instead:

```yaml
key: uv-${{ runner.os }}-${{ hashFiles(format('src/{0}/uv.lock', matrix.name)) }}
```

### 2.3. Use Filters to Trigger Only What‚Äôs Needed

Combine `dorny/paths-filter` with matrix jobs so each package runs only if its files (or shared dependencies) changed:

```yaml
filters: |
  code:
    - 'src/${{ matrix.name }}/**'
    - 'src/nt_common/**'
```

Then conditionally run steps:

```yaml
if: steps.changes.outputs.code == 'true'
```

This prevents unnecessary builds or tests.

## 3. Gate Jobs ‚Äî One Check to Rule Them All

Gate jobs aggregate matrix results so your branch protection rules only need one required check.

### 3.1. Example:

```yaml
pytest_gate:
  name: pytest_result
  needs: [pytests]
  runs-on: ubuntu-latest
  if: always()
  steps:
    - run: |
        echo "Matrix result: ${{ needs.pytests.result }}"
        if [ "${{ needs.pytests.result }}" != "success" ]; then
          echo "Some matrix jobs failed. See details in Actions run."
          exit 1
        fi
```

Now your branch protection only needs to require `pytest_result`, not each individual job.

## 4. Concurrency ‚Äî Smarter, Not Harder

When you push new commits to a PR, older runs become obsolete. Cancel them automatically to save resources.

### 4.1. Example:

```yaml
name: CI_global

on:
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  pre_commit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
      - uses: pre-commit/action@v3.0.0
```

This ensures that only the latest workflow for each PR remains active.

## 5. Putting It All Together

These techniques form a cohesive CI/CD strategy:

* Reusable hooks for shared logic.
* Matrix jobs for scalable parallel execution.
* Gate jobs for clean PR checks.
* Concurrency to avoid redundant runs.

Together, they make your workflows **modular, efficient, and production-ready**.

## 6. Key Takeaways

* **Reusable hooks:** maintainable and DRY.
* **Matrix + filters:** scalable and efficient.
* **Gate jobs:** reliable single-point validation.
* **Concurrency:** resource-smart and fast.

Your CI should scale with your codebase ‚Äî not slow it down.
