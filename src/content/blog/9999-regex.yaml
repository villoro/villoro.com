# --------------------------------------------------------------------------------------------------
# Basic metadata
# --------------------------------------------------------------------------------------------------
code: regex
title: Using regexs with python
title_short: Regexs with python
date: "2020-04-03"
image: default.png
highlight: True

tags:
  - Python
  - regex

tags_filter:
  - Python

# --------------------------------------------------------------------------------------------------
# Extra info. This will add a button with href to the url
# --------------------------------------------------------------------------------------------------
# link: 
#   text: Github
#   url: https://github.com/villoro/villoro_posts/tree/master/0035-ing_api


# --------------------------------------------------------------------------------------------------
# Content
# --------------------------------------------------------------------------------------------------
brief_markdown: |
  xx

# image_head:
#   filename: pre_commit.png
#   caption: pre_commit

content_markdown: |

  ## Table of Contents

  [TOC]

  ## 1. Regex basics

  A regular expression, or **regex** for short, is a pattern describing a certain amount of text.
  The most simple regex is a regular string, like `hello` which will match the literal text `hello`.

  There are some characters with special meanings. For example `.` will match any character (except line break).
  As an example `ip.d` will match `ipad`, `ipod`, `ip@d` etc.

  If we want to only match `ipod` or `ipad` we can use `ip[ao]d`.

  ### 1.1. Brackets `[]`

  Brackets (`[` and `]`) are used for specifying which characters are allowed. It is similar to an **or** operator. As an example:

  * `[abc]`: `a`, `b` or `c`
  * `[a-c]`: `a`, `b` or `c`
  * `[^a-c]`: anything but `a`, `b` or `c`
  * `[0-9a-fA-F]`: any number or any letter between `a` and `f` or between `A` and `F`. This represents hexadecimal

  ### 1.1. Position

  It is possible to specify matches based on the position with:

  * `^`: Start 
  * `$`: End

  For example `^ab` will only match the first `ab` in `ab abc ab` ([Demo](https://regex101.com/r/TJzoA7/2))

  ### 1.2. Classes

  There are certain keywords that will match different types of characters.
  For example `\d` will match any digit (any of those `0123456789`).
  Those classes can be inversed with capital letters. As an example `\D` will match any character except a digit.

  The main classes available are:

  <table class="v-table" align="center">
    <tr class="v-table-center">
      <th class="v-table-header">regex</th>
      <th class="v-table-header">description</th>
      <th class="v-table-header">example</th>
      <th class="v-table-header">inverse</th>
    </tr>
    <tr>
      <td><code>\d</code></td>
      <td>Digits</td>
      <td><a href="https://regex101.com/r/RM6mHO/1">d_example</a></td>
      <td><code>\D</code></td>
    </tr>
    <tr>
      <td><code>\w</code></td>
      <td>Alphanumeric and/or <code>_</code></td>
      <td><a href="https://regex101.com/r/IkIMMm/1">w_example</a></td>
      <td><code>\W</code></td>
    </tr>
    <tr>
      <td><code>\s</code></td>
      <td>Whitespaces and equivalents (like tabs)</td>
      <td><a href="https://regex101.com/r/oSziKA/1">s_example</a></td>
      <td><code>\S</code></td>
    </tr>
  </table>


  ### 1.3. Quantifiers

  It is possible to specify how many times a letter or group (defined in the next section) should appear.

  As an example we want the letter `a` + the letter `b` which should appear different number of times:

  <table class="v-table" align="center">
    <tr class="v-table-center">
      <th class="v-table-header">regex</th>
      <th class="v-table-header">description</th>
      <th class="v-table-header">example</th>
    </tr>
    <tr>
      <td><code>ab*</code></td>
      <td><code>a</code> + <code>b</code> zero times or more</td>
      <td><a href="https://regex101.com/r/ob5aYo/1">example_ab*</a></td>
    </tr>
    <tr>
      <td><code>ab+</code></td>
      <td><code>a</code> + <code>b</code> one time or more</td>
      <td><a href="https://regex101.com/r/b0o38q/1">example_ab+</a></td>
    </tr>
    <tr>
      <td><code>ab?</code></td>
      <td><code>a</code> + optional <code>b</code> (zero or one time)</td>
      <td><a href="https://regex101.com/r/S91Cbe/1">example_ab?</a></td>
    </tr>
    <tr>
      <td><code>ab{2}</code></td>
      <td><code>a</code> + <code>b</code> exactly 2 times</td>
      <td><a href="https://regex101.com/r/TYBz4I/1">example_ab{2}</a></td>
    </tr>
    <tr>
      <td><code>ab{2,5}</code></td>
      <td><code>a</code> + <code>b</code> between 2 and 5 times (inclusive)</td>
      <td><a href="https://regex101.com/r/b4oI9X/1">example_ab{2,5}</a></td>
    </tr>
  </table>

  ### 1.4. Groups

  It is possible to define **groups** in regex.
  They are use to capture part of the text and are declared with parenthesis `()`.
  We can use any regex inside the group. For example if we want to math `hello`:

  * `(hello)`: capturing group ([Demo](https://regex101.com/r/8W86e1/1)) 
  * `(?P<name>hello)`: same but giving the group a name (`name` in this case)
  * `(a|b):` **or** operator in groups. It is the same as `([ab])`

  ### 1.5. Boundaries

  It is possible to declare a boundary with `\b` (with the inverse `\B`).
  A boundary means that is surrounded with a non word type character.
  It is similar to the **start** (`^`) and **end** (`$`).

  It is easier to understand it with some examples:

  <table class="v-table" align="center">
    <tr class="v-table-center">
      <th class="v-table-header">regex</th>
      <th class="v-table-header">text: <span style="background-color:white;"><code>Impossible to do</code></span></th>
      <th class="v-table-header">text: <span style="background-color:white;"><code>I'm possible :)</code></span></th>
      <th class="v-table-header">text: <span style="background-color:white;"><code>possibler</code></span></th>
      <th class="v-table-header">example</th>
    </tr>
    <tr>
      <td><code>possible</code></td>
      <td>Im<span style="background-color:yellow;">possible</span> to do</td>
      <td>I'm <span style="background-color:yellow;">possible</span> :)</td>
      <td><span style="background-color:yellow;">possible</span>r</td>
      <td><a href="https://regex101.com/r/Ygl8wW/1">boundaries_1</a></td>
    </tr>
    <tr>
      <td><code>\bpossible</code></td>
      <td>Impossible to do</td>
      <td>I'm <span style="background-color:yellow;">possible</span> :)</td>
      <td><span style="background-color:yellow;">possible</span>r</td>
      <td><a href="https://regex101.com/r/WT2kd5/1">boundaries_2</a></td>
    </tr>
    <tr>
      <td><code>\bpossible\b</code></td>
      <td>Impossible to do</td>
      <td>I'm <span style="background-color:yellow;">possible</span> :)</td>
      <td>possibler</td>
      <td><a href="https://regex101.com/r/2qDt77/1">boundaries_3</a></td>
    </tr>
    <tr>
      <td><code>possible\B</code></td>
      <td>Impossible to do</td>
      <td>I'm possible :)</td>
      <td><span style="background-color:yellow;">possible</span>r</td>
      <td><a href="https://regex101.com/r/jL4Lkv/1">boundaries_4</a></td>
    </tr>
    <tr>
      <td><code>\Bpossible</code></td>
      <td>Im<span style="background-color:yellow;">possible</span> to do</td>
      <td>I'm possible :)</td>
      <td>possibler</td>
      <td><a href="https://regex101.com/r/bnTUnx/1">boundaries_5</a></td>
    </tr>
  </table>

  ### 1.6. Flags

  It is possible to change the behaviour of the regex with some flags:

  * `(?i)`: **case insensitive**. For example `(?i)hello` will match `HELLO` ([demo](https://regex101.com/r/jr3Zrq/1))
  * `(?m)`: **multi line**. When this is active the anchor `^` will be start of line instead of start of text ([demo](https://regex101.com/r/Ol3N99/1))
  * `(?s)`: **single line**.

  ### 1.7. Greedy vs lazy

  Imagine that we have the following text:

  ```html
  <h1> Title </h1>
  <p> Hello </p>
  ```

  If we want to capture the start of an html tag (`<h1>` and `<p>` in this case) one might be tempted to use something like `<\w+>`.
  However that will match the whole line (for both lines) since we are specifying `<` followed by any text and ended with `>` ([demo](https://regex101.com/r/ZoRRT1/1)).
  If we want to stop it at the first appearence of `>` we can use the non greedy regex `<.+?>` ([demo](https://regex101.com/r/j2OnQv/1)).

  Some better alternatives are `<\w+>` or `<[^<>]+>`.

  To sum up:

  * `<.+>`: greedy
  * `<.+?>`: non greedy

  > It can also be used with other quantifiers that are not the `+`.

  ## 2. Regex with python

  ## 3. Regex with pandas

  ## 4. Regex with pyspark

  ## 5. Regex with redshift


