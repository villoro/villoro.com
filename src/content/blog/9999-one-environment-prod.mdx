---
slug: one-environment-prod
title: One Environment to Rule Them All
meta_title: One Environment to Rule Them All - Rethinking Dev, Test, and Prod
description: Do we really need dev, test, and sandbox? Explore the case for a single prod environment, how dbt handles it, how to run Python this way, and the pros and cons of going prod-only.
date: 2025-09-01
image: /images/blog/9999-glass-bridge.jpg
category: DE
tags: [Python, dbt, DE, Environments]
draft: false
---

## 1. Why multiple environments exist

### 1.1 The traditional setup: dev, test, sandbox, prod

In software and data engineering, it’s common to separate work into multiple environments. Code is built in **dev**, validated in **test/staging**, sometimes explored in a **sandbox**, and only then deployed to **prod**. The idea is simple: keep experiments and errors away from the systems that matter.

* **Dev**: engineers build and debug on small or sample data.
* **Test/Staging**: a near-prod copy used to check everything works end-to-end.
* **Sandbox**: optional space for ad-hoc experiments or prototyping.
* **Prod**: the live environment, running on real data and serving the business.

This layering reduces risk by catching problems earlier and isolating them from production.

### 1.2 What problems they try to solve

Multiple environments exist to:

* **Test safely** – experiment without risking real data.
* **Prevent data loss** – mistakes in dev/test don’t wipe out prod tables.
* **Contain breaking changes** – issues surface in lower envs first.
* **Enable collaboration** – teams can work in parallel without stepping on prod.
* **Support CI/CD** – changes move gradually from dev → test → prod, with checks at each step.

In short: more environments mean more guardrails before code reaches production.


## 2. The DBT perspective

### 2.1 How DBT handles environments

In dbt, environments live in the `profiles.yml`. Each profile contains one or more **targets** that describe how dbt should connect: warehouse, database, schema, and credentials. This design means your project code doesn’t change — dbt simply decides *where* to build models based on the target.

The important piece is how dbt uses **database/schema naming conventions**. Instead of separate databases for dev and prod, dbt encourages using the same warehouse but isolating work with naming patterns. For example:

* **Prod target** → writes to a protected schema with a prefix like `prod_salesforce`.
* **Dev targets** → write to personal schemas using the developer’s name as prefix, e.g. `villoro_salesforce`.

This allows everyone to work against the same production data and warehouse while keeping outputs separated. Developers can safely test changes in their own prefixed schemas without touching production tables.

### 2.2 Switching targets with profiles

Profiles make it easy to switch between these targets. By default, a developer might run dbt with a personal target, which builds into `villoro_salesforce`. When deploying, the pipeline switches to the `prod` target, which builds into `prod_salesforce`.

The key idea is that there’s a **protected prefix** (like `prod_`) where only automated production runs are allowed to write. Developers instead create prefixed schemas with their own names. Both environments use the same underlying warehouse and data, so development runs closely mimic production. The only difference is the schema prefix — `prod_` for production, `<user>_` for development. This convention ensures realistic testing, strict protection of production outputs, and seamless promotion from personal work to production.


## 3. One environment to rule them all

### 3.1 Running Python with only prod

In a single-environment setup, all pipelines run directly on the production infrastructure. Developers read from production data, but write to **isolated outputs** so they never touch the official production tables. This way, you get the realism of working with full prod data and compute, while keeping live dashboards and reports safe.

### 3.2 Techniques: config flags, feature toggles, schema separation

The trick is to separate outputs with configuration:

* **Schema prefixes**: production jobs write to `prod_salesforce`, while a developer might use `villoro_salesforce`. Same warehouse, same data — different schemas.
* **Environment variables**: pipelines read an `ENV` or `SCHEMA_PREFIX` variable to decide where to write. In prod, it’s `prod_`; in dev, it’s the user’s name.
* **Feature toggles**: wrap sensitive actions in conditional checks. For example:

  * In production, the pipeline actually sends emails to users.
  * In development, the same code path is triggered but guarded by a toggle so it only runs `logger.info("[DEV] Would send email to X")`. This simulates the behavior without side effects.
  * The same applies to actions like triggering external APIs, updating dashboards, or deleting data — in dev mode, they are replaced with safe no-ops or log statements.

This gives developers confidence that they’re testing full flows, but ensures no accidental production impact.

### 3.3 Real-world patterns

This mirrors dbt’s approach: one warehouse, multiple schemas. Developers get their own scratch schemas (e.g. `alice_salesforce`, `bob_salesforce`), while production runs always target the protected `prod_salesforce`. Permissions reinforce this separation — developers can’t write to `prod_` schemas, only to their own. Some teams even use clones or temp schemas for PR validation, cleaning them up automatically. The outcome is simple: everyone develops “in prod,” with full data and resources, but production outputs remain isolated and reliable.


## 4. Pros and cons

### 4.1 Advantages: simplicity, less drift, fewer surprises

* **Less infra** – only one environment to manage.
* **No drift** – everyone works in the same place, no mismatched configs.
* **Realistic dev** – you test against real data and prod-like conditions.
* **Faster cycle** – no need to promote across multiple stages.

### 4.2 Risks: less safe experimentation, higher blast radius

* **Unsafe tests** – mistakes can impact prod data if not isolated.
* **Bigger blast radius** – a bad query or heavy job can hurt live workloads.
* **Hard to stage big changes** – limited space for dry runs.
* **Onboarding stress** – new devs must be careful from day one.

### 4.3 Mitigation strategies

* **Schema prefixes** – `prod_salesforce` for prod, `villoro_salesforce` for dev.
* **Permissions** – devs can’t write to `prod_` schemas.
* **Feature toggles** – in dev, replace side effects (e.g. email sending) with safe logs.
* **CI in temp schemas** – build and test in throwaway schemas before merging.


## 5. Closing thoughts

### 5.1 When it makes sense to go prod-only

* Small teams that can coordinate easily.
* Mature pipelines with solid tests and monitoring.
* When cost and simplicity matter more than strict safety.

### 5.2 When you probably still want multiple environments

* Large or complex systems with many users.
* Workflows tied to external services.
* Heavy experimentation and schema changes.
* Regulated or sensitive data where staging is mandatory.

